{"name":"websockets-mixed-content","tagline":"Please, don’t treat secure WebSocket subprotocols as mixed content","body":"# Goal\r\n\r\nCurrently, the mixed-content restrictions in Firefox and the WebSocket API spec [WS-API] prevent use of insecure `ws://` URLs in webapps served over HTTPS. This is a problem, because the protocol used over the WebSocket connection may include a suitable method for ensuring confidentiality and integrity of the data, so the restriction is tighter than that actually required for security.\r\n\r\nThis document justifies loosening the restriction in browsers, for suitable WebSocket subprotocols.\r\n\r\n# Use cases\r\n\r\nA webapp must be securely served: a user should not ever have to type a password into a page which was served over HTTP insecurely. Arbitrary JavaScript could have been injected to skim the user’s input and activity.\r\n\r\nA webapp for SSH or VNC provides a core example: the webapp has to be able to make peer-to-peer connections to other machines, which do not have centrally-issued identities. Most or all of the readers of this document will be users who commonly connect to SSH servers which do not have a globally-registered DNS name (eg named only on a private subnet), and these servers are troublesome to provision with certificates that are recognised by a browser’s CA system. Therefore, using TLS for the connection is not straightforward, let alone the fact that it is redundant because the protocol does its own management of identities and encryption. (A JavaScript client can implement an encrypted protocol over a WebSocket connection through the WebCrypto API.)\r\n\r\nProviding a VNC or SSH client in the browser really needs a way to allow access selectively to `ws://` connections from the HTTPS-served page.\r\n\r\n# Is a WebSocket connection ‘passive’ or ‘active’ content?\r\n\r\nBrowsers have a notion of active and passive content - content which can perform an action to affect multiple elements across a page, or has a purely passive role. A browser executes the contents of resources loaded by `<style>` or `<script>` tags, so these are clearly active, but it safely parses and displays a resource specified by an `<img>` tag. Classifying WebSockets and XHR is difficult, because strictly speaking they’re neither active nor passive, but can be used as either.\r\n\r\nFor safety, browsers classify XHR as active, because it is overwhelmingly common for a document to be returned and then inserted into the page. Historically, Firefox has seen WebSockets as active, but Chrome has not.\r\n\r\nThe recommendation of this document is to sidestep this debate by simply refining the notion of ‘mixed-content’ for WebSocket connections to take into account the WebSocket subprotocol. If a connection is deemed not to be mixed, then it doesn’t matter whether it’s active or passive.\r\n\r\n# The recommendation: don’t treat secure WebSocket subprotocols as mixed content\r\n\r\nThe WebSocket API currently includes this requirement:\r\n\r\n> If _secure_ is false but the origin of the entry script has a scheme component that is itself a secure protocol, e.g. HTTPS, then throw a `SecurityError` exception and abort these steps.\r\n> [ HTML, 10.3.2 The WebSocket interface ] (http://www.whatwg.org/specs/web-apps/current-work/multipage/network.html#the-websocket-interface)\r\n\r\nI suggest altering this to place step 4 above 2 (normalising the _protocols_ argument) and altering step 2 as follows:\r\n> If _secure_ is false and _protocols_ is an empty array or includes an insecure protocol, but the origin of the entry script has a scheme component that is itself a secure protocol, e.g. HTTPS, then throw a `SecurityError` exception and abort these steps.\r\n\r\nThe notion of ‘insecure protocol’ must be defined. Protocols which include their own encryption and integrity control need not be encapsulated by TLS to match the security of the containing page. Browsers could either:\r\n\r\n1. Extend the WebSocket API to allow a webapp to declare that an unknown subprotocol is ‘secure’. For example, the elements in the _protocol_ array could be taken to be either strings, or an object with `string name` and `bool isSecure` attributes.\r\n1. Simply regard any explicit WebSocket subprotocol as secure. Use of subprotocols is not widespread at all at the moment, and this may be an acceptable starting point. (The mixed-content checks are ultimately advisory and are a second-layer of protection which don’t confer security by themselves, they just break sites that are doing something dodgy. If site admins could be trusted to be virtuous, mixed-content protection wouldn’t be needed.)\r\n1. Include a configuration parameter with some sensible initial values. Getting support for new protocols would be a big pain though and an annoying barrier to entry.\r\n\r\nFinally, the section 10.3.3 \"Feedback from the protocol\" needs to be updated:\r\n\r\n> 3. Change the _protocol_ attribute's value to the subprotocol in use, if is not the null value. If it is the null value and _secure_ is false but the origin’s scheme is a secure protocol, then:\r\n>     1. Change the readyState attribute’s value to CLOSED (3).\r\n>     1. Close the WebSocket connection.\r\n>     1. Fire a simple event named error at the WebSocket object.\r\n\r\n# What about other request types?\r\n\r\nThe same argument applies to XHR and Events, but these are not as important as getting WebSockets to work.\r\n\r\nFor example, it’s possible that content served as an XHR response will be properly verified by the requesting page. The webapp’s JavaScript could include a list of content hashes (served securely), then do some non-TLS XHR requests, and check that the result matches one of the hashes before using the response.\r\n\r\nThese use-cases are unknown (or extremely rare) in the wild. WebSockets is the most general protocol, in that any application of XHR requests or Server-Sent Events could also be done with WebSockets, so it’s not high priority to do something too general which includes XHR and Events as well.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}